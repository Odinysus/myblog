### 前言
本篇继续介绍抽象工厂,如果想要了解简单工厂与工厂方法的实现,请看我上一篇文章 [设计模式:工厂方法--Objective-C实现](http://www.jianshu.com/p/b811774ffef1)
### 一个例子
假如现在要开发一款聊天的APP,并已经确定了需求为:该APP有VIP系统,这个VIP系统可能影响到界面UI,以及部分功能.但是目前只确认两个地方有影响:

1. 头像,VIP的头像右下角有个V小图标显示.VIP的头像有紫色边框.
2. UIButton.会员的button的颜色不同.

可以看到,在编写代码的时候并不知道用户的具体类型.而且,普通用户跟VIP用户有着相似的动作.
当然,我们可以用`if else`,但那样子,不仅麻烦,而且代码不容易维护.更何况这么做会显得你太low了不是吗?  
这里的情况有别与工厂方法的情况,对于工厂方法,生成的对象是一种类型的产品.比如上一篇文章的表单控件.控件就只有一种类型.而在当前的需求中.客户端委托工厂生成多种类型的产品.
所以在抽象工厂定义多个接口,生成对应的产品.并让子类觉得具体的类,而我们不需要知道具体的类.
### 定义
由上面所述,我们可以引出定义:**提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类**。  
即可以可以生产多种不同类型的产品.
### 实现
得到UML模型图.
![abstract factory](https://cl.ly/3O3M2g2H3E30/download/abstract%20factory.png)
我们继承了抽象工厂类(协议)`vipFactoryProtocol`获得两个具体的工厂类`NonVipFactory`和`vipFactory`.  
然后,对于非会员的情况,调用`NonVipFactory`的类方法`+ makeButton`生成对应的`NonVipButton`,调用类方法`+ makeAvatar`生成 `NonVipAvatar`.`VipFactory`则同理.而判断当前用户的身份的逻辑则需要在客户端实现.  
详细代码在github上面[AbstractFactory](https://github.com/johnMaster/AbstractFactory)
### 使用条件
* 不知道要生成的具体的类
* 每一种类都有其相似的方法
* 客户端有多个不同种类的产品类

只要符合前两个条件就直接使用使用工厂方法了,但多了第三个方法.
抽象工厂是在工厂方法原有的基础上进行了扩展,使当前客户端能生成不同种类的产品.

### 总结
抽象工厂是定义了多个创建不同类型的接口,并无需指定具体类.能够为系统提供不同的控件类型.它在工厂方法的基础上进行了扩建多类型的对象的扩展.  
抽象工厂多应用于框架中.当APP的需求为动态(即编码时无法确定类型),且将来很有可能扩展时,是应用抽象工厂的最好时机.
### 引用文章
[设计模式-可复用面向对象软件的基础](https://book.douban.com/subject/1052241)  
[Abstract factory pattern](https://en.wikipedia.org/wiki/Abstract_factory_pattern)
